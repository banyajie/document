###### 什么是CAP理论？

> C（Consistency）：强一致性 - 分布式系统内多个节点能及时的同步数据。在数据同步过程中是不可以对外服务的，否则会出现数据不一致性。
>
> A（Availabilty）：可用性
>
> P（Partition Toler）：分区容错性 - 一个系统虽然是分布式的，但是对外来看是一个整体，不能由于分布式系统内部的某个节点异常或者网络异常而导致系统对外提供服务异常。
>
> 
>
> Cap 理论指出在目前硬件条件下，一个分布式系统是必须保证分区容错性的，而在这个前提下，分布式系统要么保证CP、要么保证AP。无法同时保证CAP
>
> 

###### 什么是Base理论？

> 由于不可以同时满足CAP理论，所以出现了Base理论
>
> BA：Basically Available：基本可用。可以允许一定程度的不可用，比如由于系统故障、请求时间变长
>
> S：Soft state：软状态：标识分布式系统处于一个中间状态（同步数据中）
>
> E：Eventually Consistency：最终一致性。表示不要求分布式系统数据实时达到一致，允许经过一段时间后再达到一致，在达到一致的过程中，系统是可用的

###### 分布式ID是什么？有哪些解决方案？

> 开发过程中，我们需要一个唯一标识数据的ID。如果是单体架构，可以采用自增的数据库主键、redis维护自增的数据。但是分布式系统中。可能会有ID冲突
>
> - uuid - 复杂度低、但是影响性能和空间
> - 利用单机数据库的自增主键作为分布式系统ID的生成器 - 性能低
> - redis（自增命令）、zookeeper（顺序节点） 的特性生成ID - 性能相对较高
> - snowflak - 雪花算法
>   - 通过某台机器在某一毫秒内对数字自增

###### 分布式锁应用场景？有哪些实现方案？

> 单体架构中，多个线程是在同一个进程中的，如果涉及到共享资源的访问的时候可以通过 ReentantLock、synchornized 等作为锁来控制共享资源的使用
>
> 但是分布式架构中，多个线程可能处于不同的进程中
>
> - zookeeper：利用zookeeper的临时节点、顺序节点、watch机制来实现。特点：高一致性
> - redis：setnx、lua脚本、消息订阅

###### 什么是分布式事务？有哪些实现方案？

> 在分布式系统中，一个业务处理可能涉及多个应用。比如用户发送一次下单请求（下单、订单创建、库存、金融）所以。这些操作应该是要么都成功、要么都失败
>
> 方案：
>
> - 基于XA协议的：两阶段提交、三阶段提交。需要数据层面支持
> - 基于事务补偿机制：TCC。基于业务层面实现
>
> - 本地消息表：
>
>   - 创建订单时，将减库存消息加入到本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统。如果调用成功则修改本地消息表的状态为成功，如果失败则由后台定时去拉取失败的消息去再次处理
>
>   
>
> - 消息队列：
>
>   - 比如RocketMQ支持事务消息
>     - 生产者订单系统发送一个half消息到broker
>     - 再创建订单，根据订单创建的成功，向broker发送 callback 或者commit
>     - 并且生产者订单系统还可以提供broker回调接口，当broker一段时间后未收到任何 callback或者commit指令。则可以主动调用接口查询订单是否创建成功
>     - 一旦half消息commit。消费者库存系统就来消费。消费成功消息销毁。事务结束
>     - 如果消费失败....
>
> - Seata：
>
>   - 分布式框架：AT、TCC、底层基于两段式提交实现
>
>   

###### 负载均衡策略？

> - 轮询法
> - 加权轮询法
> - 随机法
> - 加权随机
> - 原地址hash
> - 最小连接数

###### 集群、SOA、分布式、微服务的概念和区别？

> - 集群
>   - 不同服务器部署同一套应用服务同时对外提供服务，实现服务的负载均衡以及热备、主从。指同一套服务的不同实例
> - 分布式
>   - 服务的不同模块部署在不同的服务器上，单个节点不能完整的提供服务，需要多节点协调提供服务（也可以是相同组件部署在不同服务器上，通过通信交换数据协作提供服务），分布式强调的是工作方式
> - SOA
>   - 面向服务的架构，一种设计方法，包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统中。各个服务之间可以通过网络调用。
>   - 中心化实现
>     - ESB（企业服务总线）：各服务通过ESB通信交互，解决异构系统之间的连通性，通过协议转化、消息解析、消息路由把服务提供的数据送到消费者。
>   - 去中心化 - 微服务
> - 微服务
>   - 业务需要彻底的组件化和服务化。原有的单个系统拆分为多个可以独立运行、独立部署的小程序
>   - 服务单一职责
>   - 轻量级通信

###### 分布式系统的设计目标

> - 可扩展性
>   - 通过对服务、存储的扩展提高系统的处理能力，通过多台服务器协作来完成单台服务器无法处理的任务。高并发、大数据量的任务
> - 高可用
>   - 单点不影响整体
> - 无状态
>   - 单点机器故障不影响整体。可以随时扩展
> - 可管理
>   - 便于运维
> - 高可靠
>   - 数据持久化、数据一致性

###### 两阶段提交、三阶段提交、TCC

> - 两阶段提交
>
>   - 1：事务管理器向资源管理器发送prepare消息，但是未提交事务
>   - 2：如果节点一种的所有prepare操作成功、失败。在通知资源管理器提交或者回滚事务。
>   - 3：只有协调器有超时处理
>   - 问题
>     - 单点故障 - 一旦事务管理器故障，这个系统不可用
>     - 数据不一致：阶段二如果事务管理器下发的所有commit消息未全部成功
>     - 响应时间较长：参与者、协调组资源都被锁住
>     - 不确定性：宕机后重启的事务管理器无状态
>     - 
>
> - 三阶段提交
>
>   - 主要针对2阶段提交里面的单点故障问题。但是性能问题和不一致问题仍没有解决。
>   - 引入了超时机制解决参与者阻塞的问题。二阶段只有协调器有超时机制
>   - 
>   - 1：发送 CanCommit 消息，确认数据库是否正常
>   - 2：发送 PreCommit 消息，执行事务但是不提交
>   - 3：发送 DoCommit 消息，提交或者回滚
>
>   
>
> - TCC（带补偿机制）Try、Confirm、Cancel
>
>   - 针对每个操作，都要注册一个与其对应的确认和补偿操作
>   - Try 操作做业务检查以及资源预留
>   - Confirm 做业务确认操作
>   - Cancel 实现一个与Try想反的操作即回滚操作
>   - 过程
>     - TM 首先发起所有分支事务的Try操作，任何一个分支执行失败。都会发起Cancel操作。全部分支执行成功后。发起Confirm操作。如果Cancel或者Confirm失败，会重试
>   - 缺点
>     - 侵入性强，改造难度大
>     - 幂等

###### 分布式共识

###### Posix

> 

###### Raft ?

>

###### Zab 协议？

> ZAB 协议是zookeeper用来实现强一致性的原子广播协议，该协议描述了zookeeper是如何实现一致性的：
>
> - 领导者选举阶段：
>   - 
> - 数据同步阶段：
>   - 
> - 请求广播阶段：
>   - 

###### 
