#### OSI网络模型



#### TCP（传输控制协议）

###### 特点

- 基于连接的：数据传输需要建立连接
- 全双工的：可以双向通信
- 字节流：不限制数据大小，打包成报文段，保证有序接收，重复报文自动丢弃
- 流量缓冲：解决双方处理能力的不匹配
- 可靠：保证可达，丢包时通过重发机制实现可靠性
- 拥塞控制：防止网络出现恶性拥塞



###### 协议格式

![image-20220519182030370](/Users/banyajie/Library/Application Support/typora-user-images/image-20220519182030370.png)

- source port
- dest port
- seq num - 序列号
- ack num  - 应答号    和seq num配合保证数据包的可靠性传输
- header length
- cwr
- ece
- urg：urg标志。标识紧急指针是否有效
- ack：表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段
- psh：提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）
- rst：表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段
- syn：表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段
- FIN：表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。
- receive window：数据窗口大小
-  checksum：校验和。由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- urgent data pointer：紧急数据指针
- data：报文



##### 建立连接

三次握手：



##### 关闭连接

四次挥手：



##### 问题

- 为什么是三次握手？

  - 客户端 -> FIN -> 服务端
  - 服务端 -> FIN + ACK -> 客户端
  - 客户端 -> ACK -> 服务端
  - 

- 为什么是四次挥手？

  - 过程

    - 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入FIN_WAIT_1 状态
    - 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态
    - 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入LAST_ACK 状态，等待来自客户端的最后一个ACK
    - 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

    

  - 为什么需要四次？

    - 

- TCP 的可靠性如何保证的？

  - 三次握手、四次挥手保证连接的建立、断开的可靠性
  - 有状态：tcp会记录哪些数据发送了。哪些数据接收了，哪些没有被接收，并且保证数据的有序。保证数据传输不出错误
  - 可控制：报文校验、ack、超时重传（发送方）、失序重传（接收方）、丢弃重复数据、流量控制、拥塞控制

  

- TIME-WAIT 状态为什么需要等待 2MSL

  - 2MSL（两个最大段生命周期）
  - 一个MSL保证四次挥手中主动关闭方最后的一个ack报文能到达对端
  - 一个MSL保证对端没有收到ack那么进行重传的FIN报文可以到达

  

- tcp 和 udp 的区别？

  - tcp面向连接的。udp发送之前不需要建立连接
  - 可靠性
  - tpc是点对点的。udp可以点对点、一对多、多对多
  - tcp传输效率低
  - tcp面向字节流 udp是报文

  

- tpc重传机制

  - 超时重传
    - 间隔时间RTT（Round-Trip Time）往返时间
  - 快速重传（快速重传机制，它不以时间驱动，而是以数据驱动。它基于接收端的反馈信息来引发重传。）
  - 带选择确认的重传（SACK）

  

- 滑动窗口

  - 原理
    - 如果tcp数据包一个个的发送，并且等到ack后再发送下一个数据包。这样效率比较低。所以在操作系统层面开辟了一个空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值
    - 就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。
  - 发送窗口
    - <img src="/Users/banyajie/Library/Application Support/typora-user-images/image-20220520094520142.png" alt="image-20220520094520142" style="zoom:67%;" />
    - 虚线矩形框，就是发送窗口。
      SND.WND: 表示发送窗口的大小,上图虚线框的格子数就是14个。
      SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。
      SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。
  - 接收窗口
    - <img src="/Users/banyajie/Library/Application Support/typora-user-images/image-20220520094649540.png" alt="image-20220520094649540" style="zoom:67%;" />
    - REV.WND: 表示接收窗口的大小,上图虚线框的格子就是9个。
      REV.NXT:下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。

- 流量控制

  - 

- tcp的拥塞控制

  - 拥塞控制是作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟流量控制又有什么区别呢？流量控制是作用于接收者的，根据接收端的实际接收能力控制发送速度，防止分组丢失的。

  - 常用算法

    - 慢启动
      - 慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）。每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。
    - 拥塞避免
      - 
    - 拥塞发生
    - 快速恢复
    - 慢启动算法

    

- 半连接队列和SYN Flood 攻击

  - TCP进入三次握手前，服务端会从CLOSED状态变为LISTEN状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列），TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，即半连接队列。
    当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列
  - SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造不存在的IP地址,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接，半连接队列满了，这就无法处理正常的TCP请求啦。
  - 解决方案
    - syn cookie：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
    - SYN Proxy防火墙：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。
      

- tcp的粘包和拆包

  - 为什么会产生粘包和拆包呢?
    - 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
      接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包
    - 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
  - 解决方案
    - 发送端将每个数据包封装为固定长度
    - 在数据尾部增加特殊字符进行分割
    - 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小



##### HTTP



###### 报文格式

![image-20220520105325031](/Users/banyajie/Library/Application Support/typora-user-images/image-20220520105325031.png)

```shell
POST /user HTTP/1.1                       // 请求行
Host: www.user.com
Content-Type: application/x-www-form-urlencoded
Connection: Keep-Alive
User-agent: Mozilla/5.0.                  // 以上是请求头
（此处必须有一空行 |                         // 空行分割header和请求内容 
name=world                                // 请求体(可选，如get请求时可选)

```



- 请求行

  - 请求方法
  - URL
  - 协议版本

- 请求头

  - ```shell
    //这些请求头都需要有了解的
    User-Agent：产生请求的浏览器类型(火狐还是谷歌浏览器)
    Host：请求的主机名，即请求的网址
    
    connection：连接方式(close 或 keepalive)
    keepalive是指保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
    -*-在 HTTP1.1中所有的连接默认都是持续连接-*-，优点在于避免了建立/释放连接的开销。
    
    Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie
    Content-Type：代表发送端（客户端|服务器）发送的实体数据的数据类型  text/html;charset=utf-8，application/json
    Accept：代表发送端（客户端）希望接受的数据类型text/html;charset=utf-8，application/json
    。。。还有很多
    
    
    ```

- 请求体

  - body数据：json或者xml或者form表单

###### 请求方法

GET：主要用于获取信息，查询参数会拼接在URL中，显示在浏览器地址栏。

POST：主要用于提交表单，提交的内容会包含在正文中。

PUT：主要用于更新资源。

DELETE：主要用于删除资源。



###### 应答报文

![image-20220520105826276](/Users/banyajie/Library/Application Support/typora-user-images/image-20220520105826276.png)



响应行

响应头部

```shell
Date标头：响应产生的时间
Age标头:（从最初创建开始）响应持续时间
Server标头: 向客户端标明服务器程序名称和版本
Content-Length标头：响应实体的长度
Content-Tyep标头：响应实体的类型
。。。还有很多


```



###### 状态码类别

- 1**：信息性状态码 - 接收的请求正在处理
- 2**：success - 正确处理完成
- 3**：重定向状态码 - 需要进行附加操作完成处理
- 4**：客户端错误状态码
- 5**：服务器处理请求出错



###### 问题

- Get 和 Post 请求的区别 ？

  - 其实讨论GET和POST的区别，从协议的本身看其实GET和POST只是一种标识而已，更多的时候是一种使用规范。因为用符合规范的方式去实现系统可以减少很多工作量
  - GET 是幂等的。Post是非幂等的。（意思是get请求是查询。不会改变服务器数据状态）
  - **GET/POST的参数都可以放在URL或者Body里**。只是RESTFUL风格里规范要求，GET被专用于获取资源或者资源列表，参数放在URL里；POST用于“创建一个资源”，参数放在Body里
  - **GET不如POST安全，因为POST用body传输数据，而GET用url传输**。但是其实无论是GET还是POST都不够安全，因为HTTP本身是**明文协议**。如果想安全应该使用Https
  - Get将header和data一起发送一次，POST先发送header，让服务器校验，如果收到服务器响应“100 - Continue”再发送data。Http提供了这样的Continued协议，但是发送一次还是发送N次，客户端其实可以很灵活的决定，而不是受限制。比如说如果POST的数据很小，那一次性发送给服务器反而更好，节省了一次Round trip.
  - GET URL会有长度上的限制，则POST的由于使用Body则可以非常大。HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。一般都不会出现超2kURL，参数过多可以使用body来传输数据，GET + body还是POST + body可以看情况决定。

- HTTP中哪些是长链接，哪些是短连接？

  - **长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道
  - **短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。
  - 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接

- Http 2.0, 1.1和1.0的区别？

  - 1.0

    - 优点：主要定义HTTP的报文格式包括了请求行+请求首部+数据
    - 缺点
      - 短连接，链接不能复用增大了开销
      - 发送一次请求时，需要等待服务端响应了才可以继续发送请求

  - 1.1

    - 在请求头里面加入了一个connection：keepalive，默认连接不会关闭
    - 缺点
      - 要求严格串行的返回响应，即使客户端可以同时发送多个请求，但服务端必须按照请求发送的顺序返回响应。即使后续的请求服务端已处理完成也要等待前面的请求处理响应了才能返回。（队首阻塞）一个慢响应会阻塞所有后续请求；
      - 明文数据没有进行压缩
      - header首部行太长

  - 2.0

    - 优点
      - 对明文数据转换为二进制，并且对二进制进行压缩
      - 多路复用，单连接+帧的形式，类似于BT下载把文件打散成块
      - 首部行太长进行首部压缩

    

- 浏览器输入请求到返回结果的过程?

  - 1：域名解析
    - 搜索浏览器自身DNS缓存，如果没有过期，则搜索结束
    - 如果浏览器自身缓存没有，则搜索本地系统中的DNS缓存，如果本地没有解析出来，则查看本地hosts文件
    - 如果无，则远端发起DNS域名解析
  - 2：发起tcp三次握手
  - 3：建立tcp链接后发起http请求
  - 4：服务器响应http请求，浏览器得到html代码
  - 5：浏览器解析html中的资源，并请求资源
  - 6：tcp四次挥手

  

- http协议缓存方式

  - http缓存

    - 强缓存：强缓存的意思很简单，直接从浏览器缓存过的本地进行读取，不会去请求服务器。例如请求一个图片，当缓存后，第二次访问，直接从本地去拿，不会再去请求这个资源，可以节省服务器资源。可以通过三种方式来设置强缓存
      - Expires：服务端在响应头中设置一个 GMT 格式的到期时间。客户端的本地时间小于响应头的 Expires 时间，那么会从本地进行读取，不会去请求服务器。如果超过了，那么就去请求服务器去获取最新资源。但是就是因为根据本地时间进行判断，本地时间可以随便修改，所以这种缓存机制有漏洞，
      - Cache-control：他和Expires不一样，Expires是直接设置一个时间戳就行了，而Cache-control可以设置下面这几种属性
        - max-age：这个用于设置一个滑动时间，例如设置 max-age=30 表示客户端时间向后滑动30秒，在这30秒内都是强缓存，不会去请求服务器
          s-maxage：这个和上面的一样，只不过这个设置的是代理服务器的缓存时间
          privte：这个表示缓存只能被客户端的浏览器缓存，不能被代理服务器缓存
          public：这个表示缓存既可以被浏览器缓存，也可以被代理服务器缓存
          no-store：这个属性表示不缓存，在任何情况下，都是与服务器进行最新的交互
          no-cache：这个并非不缓存的意思，这个表示强制进行协商缓存，会在下面描述
      - 
    - 协商缓存：协商缓存主要是解决强缓存资源不能及时更新的问题
      - last-modified 配合 If-Modified-Since：
        - 例如，客户端请求一个 03.jpg，服务端接收到这个请求后，会读取这个文件的最后修改时间，然后设置到响应头中，设置的参数就是 last-modified，参数值是文件最后修改的时间戳。客户端第二次请求 03.jpg 这个文件的时候，会带上一个 If-Modified-Since 参数，服务端能拿到这个参数与last-modified进行比对，如果一致，那么就返回304状态，否则就去请求最新的文件，
      - Etag 配合 If-None-Match：
        - Etag实现的方式服务端是为文件生成一个指纹，类似于MD5字符串。接着响应头中塞进 Etag 参数，参数的值就是计算出的字符串，客户端接收到后，第二次请求会带上一个 If-None-Match 的参数，接着服务端和上面第一种方式一样进行比对
        - 

  - 浏览器缓存

    - 本地存储
      - cookie、sessionStage、localStore、WebSql
    - 默认缓存

    

- http和https的区别

  - https = http + SSL/TLS(安全套接层)
  - https协议多了一层TLS协议。TLS的握手过程用到了非对称加密，而建立连接后的通信用到了对称加密
  - TLS握手过程
    - 建立TCP连接后
    - 浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表
    - 服务器接收到，立即返回 server_random，确认好双方都支持的加密套件 以及数字证书 (证书中附带公钥 Public key certificate)。
    - 浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA  算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器
    - 服务器用私钥解密这个被加密后的 pre_random
  - 对称加密
    - 加、解密使用的同一串密钥，常见的对称加密算法：DES，AES 等。
  - 非对称加密
    - 加、解密使用不同的密钥，一把作为公开的公钥，另一把作为保密的私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。
  - 混合加密
    - 在通信刚开始的时候使用 `非对称加密` 算法，解决密钥交换的问题。后续全都使用 `对称加密` 进行通信。

  

