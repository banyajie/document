##### 需求分析

- 添加好友
- 聊天会话列表
- 单聊
- 群聊
- 多设备登陆
- 消息漫游
- 消息已读，查看已读、未读列表



##### 要求

- DAU 10亿
  - qps：假如每人每天发送100条消息，qps = 10亿*100/86400 = 12 millón qps
  - 存储
  - 峰值预估
- 可靠性
- 收发消息低延迟10ms以下
- 消息时序一致性（发送端和接收端消息时序一致，不重复不丢）
- 万人群聊
- 可运维



##### 基础可行性方案

<img src="/Users/banyajie/Library/Application Support/typora-user-images/image-20220622094731225.png" alt="image-20220622094731225" style="zoom:67%;" />

- 客户度轮询通过 IM Server 拉取消息
- 加好友
- 单聊
- 多设备
- flag已读标记
- 





##### 优化方案

##### 高性能

###### 接入层优化

- 轮询拉取模式，无法满足实时性要求，消息不及时
  - 长链接，pull、push结合
- 客户端如何和服务端建立长链接
  - 客户端只能通过公网IP，SocketTCP 直接连接服务器
  - 通过一个IPConf服务下发公网IP给客户端，灵活扩展并可智能调度长链接
  - 建立长链接后IM Server业务层拿到FD和uid的映射
  - IPconf通过协调服务与IM Server做服务发现，根据机器的负载进行负载均衡
- 长链接占用内存，IO密集度高，而业务层数据库操作频繁
  - 接入层、业务层分离
  - 长链接负责维护状态以及收发消息，IM Server负责业务
- 长链接服务为维持最优的消息通路，常常需要以连接维度存储大量状态信息，用于做各种调度策略优化网络通信。有状态。
  - 变与不变的业务尽量分离，隔离
  - 不变的消息通路（长链接网关）保证不会频繁迭代
  - 长链接服务同步更新state server，Ipconf服务读取状态信息用于旁路调度
  - State通过状态控制长链接的断开
- 如何知道客户端B的长链接在那个接入层服务器上，进行消息路由并保证消息可达？
  - 广播
    - IM Server将消息给所有的接入层服务器广播，接入层服务器收到后只处理自己持有的uid的链接
  - 一致性hash
  - 路由服务层

###### 存储层优化

- 读写比1:99999，超大群每人发送一条消息要一亿分发量，如何控制超大群将机器资源耗尽
  - 并发控制，做到按群维度限制最大并发量
- 限制并发量后导致消息积压，应该如何处理收发消息延迟增大的问题？
  - 达到限制后，如果有消息积压，可以压缩批量下发
  - 推拉结合
- 存储上存在很明显的写放大（写扩散），如何减少写入数据量，降低存储成本
  - 对超大群降级为读放大模式存储，消息仅同步写入收件箱
  - 群状态消息，如回执消息写入HBase存储
- 消息回执如何处理？如何保证万人群聊中已读、未读列表一致性
  - 实时流处理，对于接受者已读消息的下发要同步执行，而接受者的消息已读可以异步落库
  - 对于超大群，群状态变更服务进行降级，不再发送信令
  - 异步写入保证最终一致性
- db设计
  - 分级存储
    - uid维度在memDB中维护可排序的list，可根据活跃程度调节最大条数
    - 超大群聊退化成读扩散模式，维护会话级别的list并异步缓存消息状态
    - 根据群聊的会话ID对消息列表进行本地LRU缓存，对列表的大小进行限制
    - protobuf进行序列化压缩处理
    - 本地缓存的LRU使用HotRing算法，测算热点
    - 使用消息队列广播消息状态的变化给到本地缓存，或者使用Gossip算法
    - 限制拉取会话消息的切片范围，最多到memDb级别
    - 对于超过一定时间的数据压缩后存储在文件系统中
  - 多元DB存储
    - rocksdb、mongDB
    - 
  - 图数据库
  - 存储层代理服务
  - <img src="/Users/banyajie/Library/Application Support/typora-user-images/image-20220622185158473.png" alt="image-20220622185158473" style="zoom:80%;" />



##### 消息时序一致性

- 如何保证消息不丢？
  - 上行消息客户端重试
  - 下行消息服务端重试
  - ack机制，避免无限重试
- 如何防止重复？
  - UUID 是否可行
  - 上行
    - 客户端维护一个会话内生成一个消息自增的cid，服务端存储当前会话收到的最大cid
    - 如果发送的消息不是max_cid+1，则丢弃
  - 下行
    - 服务端为每个发送的消息分配seqID，客户端维护收到的最大的seqID
    - 如果发送的消息的seqID不是max_seqID+1，则丢弃
- 如何保证消息有序？
  - 按照某个递增的ID排序
    - 上行
    - 下行



##### 高可用

- 跨域公网的长链接如果断了怎么办？
  - 心跳保活
  - 
  - 断线重连
  - 心跳风暴
  - 
  - 
  - 
  - 弱网环境如何保证消息可达



##### 异地多活架构

