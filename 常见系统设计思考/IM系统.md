考点：

跨端同步与否的设计思路（微信、qq）

客户端、服务端数据一致性设计思想





需求分析：

网络通信、协议、安全、存储、搜索等

IM系统中最重要的模块是：消息系统、消息系统中最重要的功能：消息的同步、存储、检索

消息的同步：将消息完整、快速地从发送方传递到接收方，就是消息的同步。

消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』

消息的存储：消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。

现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息

消息的检索：消息一般是文本，所以支持全文检索也是必备的能力之一。

传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力



IM系统中消息推送和存储框架的实现

```
消息同步库
消息存储库

TimeLine模型：
    
    
    A（client）  == 》 timeline（消息队列 - 存储、推送） == 》 B1、B2、B3（client 多端接收、同步）    


特点：
    a：每个消息拥有一个顺序ID（SeqId），在队列后面的消息的SeqId一定比前面的消息的SeqId大，也就是保证SeqId一定是增长的，但是不要求严格递增。
    b：新的消息永远在尾部添加，保证新的消息的SeqId永远比已经存在队列中的消息都大。
    c：可根据SeqId随机定位到具体的某条消息进行读取，也可以任意读取某个给定范围内的所有消息。


消息存储模型：
    A   ==  》 timeline    == 》B      会话（AB）
    A   ==  》 timeline    == 》C
    A   ==  》 timeline    == 》D
    A   ==  》 timeline    == 》E
    
消息存储要求每个会话都对应一个独立的Timeline。
如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的Timeline，每个Timeline内存有这个会话中的所有消息，服务端会对每个Timeline进行持久化。服务端能够对所有会话Timeline中的全量消息进行持久化，也就拥有了消息漫游的能力。    

    
消息同步模型：

读扩散：
    消息存储模型中，每个会话的Timeline中保存了这个会话的全量消息。
    读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的Timeline中，接收端从这个Timeline中拉取新的消息。
    
    优点：
        消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景。
    缺点：
        接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。
        
写扩散：
    写扩散的消息同步模式，需要有一个额外的Timeline来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步Timeline，用于存放需要向这个接收端同步的所有消息。
    每个会话中的消息，会产生多次写，除了写入用于消息存储的会话Timeline，还需要写入需要同步到的接收端的同步Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储Timeline，
    还需要写入参与这个会话的两个接收者的同步Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外的写N次。
    
    优点：
        在接收端消息同步逻辑会非常简单，只需要从其同步Timeline中读取一次即可，大大降低了消息同步所需的读的压力
    缺点：
        消息写入会被放大，特别是针对群这种场景。
        
在IM这种应用场景下，通常会选择写扩散这种消息同步模式。IM场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。
一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以IM系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。
当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。针对这种极端写扩散的场景，会退化到使用读扩散。
一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。  

        
                        
消息库设计：

        单聊 AB
        单聊 AC
        群聊（group） ABCDEF        
        
        消息同步库：
            消息同步库用于存储所有用于消息同步的Timeline，每个Timeline对应一个接收端，主要用作写扩散模式的消息同步。这个库不需要永久保留所有需要同步的消息，因为消息在同步到所有端后其生命周期就可以结束，就可以被回收。
            但是如前面所介绍的，一个实现简单的多端同步消息系统，在服务端不会保存有所有端的同步状态，而是依赖端自己主动来做同步。
            所以服务端不知道消息何时可以回收，通常的做法是为这个库里的消息设定一个固定的生命周期，例如一周或者一个月，生命周期结束可被淘汰
            
            基于接收方：
            
            timeline to A
            timeline to B
            timeline to c
            基于消息接收方，每个接收方对应一个timeline。用作写扩散模型的消息同步
            
        消息存储库：
            消息存储库用于存储所有会话的Timeline，每个Timeline包含了一个会话中的所有消息。这个库主要用于消息漫游时拉取某个会话的所有历史消息，也用于读扩散模式的消息同步
            
            基于会话：
                timeline to AB
                timeline to AC
                timeline to ABCDEF
                
                每个会话一个timeline。用作消息漫游和历史消息读取
  
  
  数据库选型：
             消息同步库                           消息存储库              
  模型：      timeline                            timeline
  写能力      高并发写，十万级tps                    高并发写，少量读，万级tps
  读能力      高并发范围读                          少量范围读
  规模：      保存一段时间，千万级的timeline规模      保存全量消息
  
  
总结下来，对数据库的要求有如下几点：
a：表结构设计能够满足Timeline模型的功能要求：不要求关系模型，能够实现队列模型，并能够支持生成自增的SeqId。
b：能够支持高并发写和范围读，规模在十万级TPS。
c：能够保存海量数据，百TB级。
d：能够为数据定义生命周期。
                                     
```