##### 一：高并发下分布式缓存

> 一致性hash
>
> 集群
>
> 缓存穿透
>
> - 空值缓存
>
> - 过滤器（内存过大）
>
> - 布隆算法
>
>   - 布隆算法核心
>     - 算法结果表示数据不存在，则数据一定不存在
>     - 算法结果表示数据存在，但是数据不一定存在
>
>   - hash冲突解决
>     - 增大数组
>     - 增加hash算法组
>     - 
>
> 缓存雪崩
>
> 

##### 二：分布式锁

> - redis
>   - 看门狗
>   - uuid标识
>
> - redlock 
>   - 多机
>   - 重试
>
> - zookeeper
>   - 原理
>     - 顺序节点特性
>       - 临时节点特性
>   - 分布式协调
>   - session
>   - watch
>   - path-node
>
> - etcd
>
> 

##### 三：分布式事务

> - CAP理论
>   - Consistency - 一致性：数据在多个副本节点中保持一致。保证多个同时触发的请求获得数据结果一致
>   - Availability - 可用性：服务可用
>   - Partition tolerance - 分区容忍性
>   - 
> - 分布式事务
> - 两阶段提交
>   - 
>   - 缺陷
>     - 不能完整保证事务
>     - 资源占用大、效率低
> - 三阶段提交
>   - 询问 - 预提交 - 提交
>   - 引入超时机制
>   - 
> - TCC（Try Confirm Cancel）
> - LCN （Lock Confirm notify）
> - 消息队列 + 本地事件表
> - 可靠消息服务（roket mq ）
> - 最大努力通知方案

##### 四：分布式ID生成器

> - uuid
> - mysql自增主键
> - redis
> - snowflake

##### 五：zookeeper和redis做分布式锁的区别

##### 六：设计微服务有什么原则

> - 单一职责
>   - 让每个服务能独立、有界限的工作。每个服务之关注自己的业务。做到高内聚
> - 服务自治
>   - 解耦（独立开发、独立测试、独立构建、独立运行）
> - 轻量级通信
>   - 跨平台、跨语言
> - 粒度进化
>   - 不要过度设计、可扩展
>   - 业务发展进化

##### 七：BASE理论

> 由于CAP理论无法同时满足，base理论是牺牲系统的强一致性，来获得高可用



> BA：基本可用
>
> S：soft state - 软状态
>
> E：eventually consistent：最终一致性